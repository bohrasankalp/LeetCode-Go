# "Algorithm Diagram" Notes

<p align='center'>
<img src='https://img.halfrost.com/Blog/ArticleTitleImage/Grokking_Algorithms_cover.png'>
</p>

-   binary search only works if the list is sorted

-   Big O notation indicates the **increase**in the running time of the algorithm

-   Algorithm runtime is measured in terms of its speedup
    > A quote from Leigh Caldwell on Stack Overflow, "Your program may be more performant if you use loops; it may be easier to understand if you use recursion. How you choose what to look at is more important to you."

-   Every recursive function has two parts, the base case and the recursive case. A recursive condition means that the function calls itself, and a baseline condition means that the function does not call itself any more, thus avoiding an infinite loop.

-   Optimize the recursive call stack, there are 2 methods

-   Rewrite the code to use loops instead

-   Use tail recursion. This is an advanced topic beyond the scope of this book, and not all languages ​​support tail recursion.

-   When writing recursive functions involving arrays, the baseline condition is usually that the array is empty or contains only one element.
    > Functional programming languages ​​like Haskell don't have loops, so you can only write such functions using recursion. Functional programming languages ​​are easier to learn if you have a solid understanding of recursion. If you like recursion or want to learn a new language, check out Haskell.

-   To avoid conflicts in the hash table, you need to have:

-   lower fill factor

-   good hash function

-   The edges in a directed graph are arrows, and the direction of the arrow specifies the direction of the relationship. Edges in undirected graphs do not have arrows, where relationships are bidirectional.

-   Breadth-first search seeks the shortest path. For the checked points, be sure not to check again, otherwise it will lead to an infinite loop.

-   In an undirected graph, each edge is a cycle. Dijkstra's algorithm can only be used on **directed acyclic graph**(directed acyclic graph, DAG). If there are negative weight edges, Dijkstra's algorithm cannot be used.

-   In a graph with negative weight edges, the shortest path is required, and the Bellman-Ford algorithm (Bellman-Ford algorithm) is required

-   The concept of greedy algorithm: take the optimal solution at each step. The local optimal solution is selected at each step, and finally the global optimal solution is obtained.
    \-Determine whether the problem is NP-complete

-   The algorithm runs very fast with fewer elements, but becomes very slow as the number of elements increases.

-   Problems involving "all combinations" are usually NP-complete.

-   Problems cannot be broken down into sub-problems, every possible situation must be considered. This may be an NP-complete problem.

-   If the problem involves sequences, (like the sequence of cities in the traveling salesman problem) and is hard to solve, it is probably NP-complete.

-   If the problem involves sets (like the set of radio stations) and is hard to solve, it is probably NP-complete.

-   If the problem can be transformed into a set covering problem or a traveling salesman problem, then it must be NP-complete.

-   No fast solutions have been found for NP-complete problems.

-   Faced with NP-complete problems, the best course of action is to use approximation algorithms.

-   Dynamic programming works only if each subproblem is discrete, i.e. does not depend on other subproblems.

-   Every dynamic rule solution involves a grid.

-   There is no one-size-fits-all formula for calculating dynamic programming, **dynamic programming is an art**.

-   The git diff command points out the difference between two files, which is implemented using dynamic programming.

-   A Bloom filter is a probabilistic data structure that provides answers that may not be correct, but are likely to be correct. **Misreporting may occur, but false reporting is impossible**. Bloom filters are great for situations where absolutely accurate answers are not required.

-   When faced with massive data and only require the answer to be close to ten, you may consider using a probabilistic algorithm.

-   Currently the most secure password hashing function is bcrypt, but nothing is foolproof.

-   The SHA hash function is insensitive to locality, and a single character change will cause its hash value to be completely different. Sometimes it is desirable for a hash function to be locality sensitive. In this case, Simhash can be used. If you make slight changes to the string, the hash value generated by Simhash will only be slightly different. This allows you to determine how similar two strings are by comparing the hash values. Simhash is useful when you need a similar program to check two things.
    -   Google uses Simhash to determine whether a page has been collected.
    -   Teachers can use Simhash to judge whether a student's paper is copied from the Internet.
    -   Scribd allows users to upload documents or books to share with others, but does not want users to upload copyrighted content. This site can use Simhash to check whether the uploaded content is similar to the published novel, and automatically reject it if it is similar.
